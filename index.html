<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HA Pull-down + TEV: HERC5 on Ribosomes</title>
  <style>
    :root { --pad: 14px; }

    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:#0b0f19;
      color:#e9eefc;
      display:grid;
      place-items:center;
      min-height:100vh;
      padding:var(--pad);
    }

    .card{
      width:min(1400px,100%);
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:18px;
      padding: clamp(12px, 2.5vw, 18px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }

    h1{ font-size: clamp(18px, 3.2vw, 24px); margin:0 0 6px; }
    p{ margin:0 0 12px; opacity:.9; line-height:1.35; font-size: 14px; }

    .play{
      position:relative;
      height: 720px;
      border-radius: 16px;
      background:
        radial-gradient(1200px 520px at 20% 10%, rgba(120,160,255,0.16), transparent 60%),
        radial-gradient(900px 420px at 80% 90%, rgba(120,255,200,0.11), transparent 60%),
        rgba(255,255,255,0.04);
      border: 1px dashed rgba(255,255,255,0.18);
      overflow:hidden;
      touch-action:none;
    }

    /* ===== Tube at bottom ===== */
    .tube-wrap{
      position:absolute;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      width: 240px;
      height: 210px;
      pointer-events:none;
      display:grid;
      place-items:end center;
      z-index: 5;
    }
    .tube{
      position:relative;
      width: 240px;
      height: 210px;
      border-radius: 26px 26px 40px 40px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
      overflow:hidden;
    }
    .tube::before{
      content:"";
      position:absolute;
      left: 12px;
      right: 12px;
      top: 16px;
      height: 40px;
      border-radius: 18px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.14);
    }
    .tube .fill{
      position:absolute;
      left: 12px;
      right: 12px;
      bottom: 12px;
      height: 72%;
      border-radius: 18px 18px 34px 34px;
      background: linear-gradient(180deg, rgba(120,255,220,0.10), rgba(120,160,255,0.06));
      border: 1px solid rgba(255,255,255,0.10);
    }
    .tube-label{
      position:absolute;
      top: 10px;
      left: 18px;
      font-size: 12px;
      opacity: 0.85;
      letter-spacing: 0.2px;
    }
    .tube-count{
      position:absolute;
      right: 16px;
      top: 10px;
      font-size: 12px;
      opacity: 0.9;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 4px 8px;
      border-radius: 999px;
    }

    /* ===== TEV protease tool ===== */
    .tev{
      position:absolute;
      left: 18px;
      bottom: 24px;
      width: 150px;
      height: 54px;
      border-radius: 16px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.16);
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      user-select:none;
      touch-action:none;
      cursor: grab;
      z-index: 8;
      filter: drop-shadow(0 12px 16px rgba(0,0,0,0.25));
    }
    .tev:active{ cursor: grabbing; }
    .tev .badge{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      background: rgba(255,220,120,0.20);
      border: 1px solid rgba(255,220,120,0.30);
      display:grid;
      place-items:center;
      font-weight: 900;
      color: rgba(255,240,200,0.95);
    }
    .tev .txt{
      font-size: 12px;
      opacity: 0.9;
      line-height: 1.2;
    }
    .tev .txt b{ display:block; font-size: 13px; opacity: 1; }

    /* ===== Complexes (moving left -> right) ===== */
    .complex{
      position:absolute;
      width: 220px;
      height: 120px;
      pointer-events:none; /* only HA is interactive */
      filter: drop-shadow(0 10px 14px rgba(0,0,0,0.22));
      user-select:none;
      z-index: 3;
    }

    /* Ribosome (stacked ovals) */
    .ribosome{
      position:absolute;
      left: 22px;
      bottom: 14px;
      width: 150px;
      height: 62px;
    }
    .ribo-oval{
      position:absolute;
      left: 0;
      right: 0;
      margin:auto;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(230,230,245,0.14);
    }
    .ribo-oval.one{ top: 18px; width: 150px; height: 34px; opacity: 0.9; }
    .ribo-oval.two{ top: 4px;  width: 126px; height: 30px; opacity: 0.75; }
    .ribo-oval.three{ top: 30px; width: 120px; height: 28px; opacity: 0.65; }
    .ribo-label{
      position:absolute;
      left: 6px;
      bottom: -4px;
      font-size: 11px;
      opacity: 0.70;
    }

    /* HERC5 blob */
    .herc5{
      position:absolute;
      left: 62px;
      bottom: 54px;
      width: 96px;
      height: 58px;
      border-radius: 38% 30% 42% 28% / 58% 34% 62% 36%;
      background: linear-gradient(135deg, rgba(120,170,255,0.34), rgba(255,255,255,0.05));
      border: 1px solid rgba(255,255,255,0.14);
    }
    .herc5::after{
      content:"HERC5";
      position:absolute;
      left: 10px;
      bottom: 6px;
      font-size: 11px;
      opacity: 0.75;
      letter-spacing: 0.2px;
    }

    /* HA tag nub (drag handle, but ONLY after TEV cleavage) */
    .ha{
      position:absolute;
      left: 144px;
      bottom: 78px;
      width: 58px;
      height: 28px;
      border-radius: 999px;
      background: rgba(255,220,120,0.18);
      border: 1px solid rgba(255,220,120,0.35);
      display:grid;
      place-items:center;
      font-weight: 900;
      font-size: 12px;
      color: rgba(255,240,200,0.95);
      cursor: not-allowed;
      pointer-events:auto;
      touch-action:none;
      user-select:none;
      box-shadow: 0 0 0 0 rgba(255,220,120,0);
      transition: box-shadow 160ms ease, transform 140ms ease, background 160ms ease, border-color 160ms ease, opacity 160ms ease;
      opacity: 0.92;
    }
    .ha::before{
      content:"";
      position:absolute;
      left: -18px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,220,120,0.16);
      border: 1px solid rgba(255,220,120,0.18);
    }
    .ha.hot{
      transform: scale(1.03);
      box-shadow: 0 0 0 10px rgba(255,220,120,0.10);
    }

    /* After TEV cleavage: HA turns green and becomes draggable */
    .ha.cleaved{
      background: rgba(120,255,200,0.16);
      border-color: rgba(120,255,200,0.40);
      color: rgba(200,255,240,0.95);
      cursor: grab;
      opacity: 1;
    }
    .ha.cleaved:active{ cursor: grabbing; }
    .ha.cleaved::before{
      background: rgba(120,255,200,0.14);
      border-color: rgba(120,255,200,0.22);
    }

    /* little "need TEV" pulse if user tries to drag before cleavage */
    .ha.locked-pulse{
      animation: pulse 380ms ease;
    }
    @keyframes pulse{
      0%{ transform: scale(1); box-shadow: 0 0 0 0 rgba(255,120,120,0); }
      40%{ transform: scale(1.06); box-shadow: 0 0 0 12px rgba(255,120,120,0.10); }
      100%{ transform: scale(1); box-shadow: 0 0 0 0 rgba(255,120,120,0); }
    }

    /* small toast */
    .toast{
      position:absolute;
      left: 50%;
      bottom: 255px;
      transform: translateX(-50%);
      font-size: 12px;
      opacity: 0;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      pointer-events:none;
      transition: opacity 180ms ease, transform 180ms ease;
      z-index: 20;
    }
    .toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-6px);
    }

    .hud{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items:center;
      margin-top: 10px;
    }
    .pill{
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      opacity: 0.92;
    }
    button{
      margin-left:auto;
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color:#e9eefc;
    }

    /* Modal */
    .modal{
      position:fixed; inset:0;
      display:none; place-items:center;
      background: rgba(0,0,0,0.55);
      padding: 18px;
      z-index: 50;
    }
    .modal.show{ display:grid; }
    .modal .box{
      width: min(560px, 100%);
      background:#101a2f;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
    }
    .box h2{ margin:0 0 8px; font-size:18px; }
    .box .msg{ font-size: 15px; line-height:1.4; opacity:0.95; white-space: pre-wrap; }
    .box .row{ display:flex; gap:10px; margin-top: 14px; justify-content: flex-end; }

    .hint{
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.85;
    }
  </style>
</head>

<body>
  <div class="card">
    <h1>HA Pull-down + TEV cleavage</h1>
    <p>Step 1: Drag <b>TEV</b> onto <b>HA</b> to cleave (HA turns green). Step 2: Drag the cleaved complex into the <b>tube</b>. Capture <b>5</b> to unlock the hint üéÅ</p>

    <div class="play" id="play" aria-label="Play area">
      <div class="tube-wrap">
        <div class="tube" id="tube">
          <div class="tube-label">Pull-down tube</div>
          <div class="tube-count" id="tubeCount">0 / 5</div>
          <div class="fill"></div>
        </div>
      </div>

      <div class="tev" id="tev" aria-label="TEV protease tool">
        <div class="badge">‚úÇ</div>
        <div class="txt"><b>TEV</b><span>cleave HA first</span></div>
      </div>

      <div class="toast" id="toast"></div>
    </div>

    <div class="hud">
      <div class="pill" id="status">Captured: 0 / 5</div>
      <div class="pill">Tip: TEV ‚Üí HA turns green ‚Üí tube</div>
      <button id="reset">Reset</button>
    </div>

    <div class="hint"></code></div>
  </div>

  <div class="modal" id="modal" role="dialog" aria-modal="true">
    <div class="box">
      <h2>‚úÖ Pull-down complete!</h2>
      <div class="msg" id="msg"></div>
      <div class="row">
        <button id="close">Close</button>
      </div>
    </div>
  </div>

<script>
  // ===== Customizable message =====
  const DEFAULT_MESSAGE =
`You cleaved + pulled down 5 complexes üéâ

Your present is hidden:
üëâ (edit this message in index.html)
or set it via the URL like ?msg=Your%20present%20is%20...`;

  const params = new URLSearchParams(location.search);
  const REVEAL_MESSAGE = params.get("msg") ? decodeURIComponent(params.get("msg")) : DEFAULT_MESSAGE;

  const play = document.getElementById("play");
  const tube = document.getElementById("tube");
  const tubeCount = document.getElementById("tubeCount");
  const status = document.getElementById("status");
  const resetBtn = document.getElementById("reset");

  const tev = document.getElementById("tev");
  const toast = document.getElementById("toast");

  const modal = document.getElementById("modal");
  const msg = document.getElementById("msg");
  const closeBtn = document.getElementById("close");

  // ===== Game settings =====
  const REQUIRED = 5;
  const COMPLEX_COUNT = 9;
  const FLOW_MIN_V = 0.04;
  const FLOW_MAX_V = 0.085;
  const TOP_MIN_Y = 40;
  const TOP_MAX_Y = 220;

  let captured = 0;
  let solved = false;

  const complexes = [];

  // Drag state
  let draggingComplex = null; // { c, pointerId, offsetX, offsetY }
  let draggingTev = null;     // { pointerId, offsetX, offsetY, startX, startY }

  function rand(min, max){ return min + Math.random() * (max - min); }

  function showToast(text){
    toast.textContent = text;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toast.classList.remove("show"), 900);
  }

  function updateCounters(){
    tubeCount.textContent = `${captured} / ${REQUIRED}`;
    status.textContent = `Captured: ${captured} / ${REQUIRED}`;
  }

  function reveal(){
    solved = true;
    msg.textContent = REVEAL_MESSAGE;
    modal.classList.add("show");
    if (navigator.vibrate) navigator.vibrate([40, 30, 40]);
  }

  // ===== Tube hit test =====
  function inTube(complexEl){
    const pr = play.getBoundingClientRect();
    const tr = tube.getBoundingClientRect();
    const cr = complexEl.getBoundingClientRect();

    const tubeLocal = {
      left: tr.left - pr.left,
      top: tr.top - pr.top,
      right: tr.right - pr.left,
      bottom: tr.bottom - pr.top
    };

    const inner = {
      left: tubeLocal.left + 18,
      right: tubeLocal.right - 18,
      top: tubeLocal.top + 10,
      bottom: tubeLocal.bottom - 16
    };

    const cx = (cr.left - pr.left) + cr.width/2;
    const cy = (cr.top - pr.top) + cr.height/2;

    return (cx > inner.left && cx < inner.right && cy > inner.top && cy < inner.bottom);
  }

  // ===== TEV cleavage hit test =====
  function tevHitsHA(tevEl, haEl){
    const pr = play.getBoundingClientRect();
    const tr = tevEl.getBoundingClientRect();
    const hr = haEl.getBoundingClientRect();

    const tx = (tr.left - pr.left) + tr.width/2;
    const ty = (tr.top  - pr.top) + tr.height/2;

    const hx = (hr.left - pr.left) + hr.width/2;
    const hy = (hr.top  - pr.top) + hr.height/2;

    return Math.hypot(tx - hx, ty - hy) < 70;
  }

  // ===== Build one complex =====
  function createComplex(){
    const el = document.createElement("div");
    el.className = "complex";

    const ribo = document.createElement("div");
    ribo.className = "ribosome";
    ribo.innerHTML = `
      <div class="ribo-oval one"></div>
      <div class="ribo-oval two"></div>
      <div class="ribo-oval three"></div>
      <div class="ribo-label">Ribosome</div>
    `;
    el.appendChild(ribo);

    const h = document.createElement("div");
    h.className = "herc5";
    el.appendChild(h);

    const ha = document.createElement("div");
    ha.className = "ha";
    ha.textContent = "HA";
    el.appendChild(ha);

    play.appendChild(el);

    const x = rand(-260, -60);
    const y = rand(TOP_MIN_Y, TOP_MAX_Y);
    const v = rand(FLOW_MIN_V, FLOW_MAX_V);

    const c = { el, ha, x, y, v, dragging:false, active:true, cleaved:false };
    setPos(c, x, y);

    // HA interactions:
    ha.addEventListener("pointerdown", (e) => onComplexDown(e, c));
    ha.addEventListener("pointermove", (e) => onComplexMove(e, c));
    ha.addEventListener("pointerup", () => onComplexUp(c));
    ha.addEventListener("pointercancel", () => onComplexUp(c));

    return c;
  }

  function setPos(c, x, y){
    c.x = x; c.y = y;
    c.el.style.left = x + "px";
    c.el.style.top  = y + "px";
  }

  // ===== Complex dragging (only if cleaved) =====
  function onComplexDown(e, c){
    if (solved || !c.active) return;

    if (!c.cleaved){
      // Feedback if player tries too early
      c.ha.classList.add("locked-pulse");
      setTimeout(() => c.ha.classList.remove("locked-pulse"), 420);
      showToast("Use TEV to cleave HA first ‚úÇ");
      if (navigator.vibrate) navigator.vibrate(20);
      return;
    }

    c.dragging = true;
    draggingComplex = { c, pointerId: e.pointerId, offsetX: 0, offsetY: 0 };
    c.ha.setPointerCapture(e.pointerId);

    const cr = c.el.getBoundingClientRect();
    draggingComplex.offsetX = e.clientX - cr.left;
    draggingComplex.offsetY = e.clientY - cr.top;

    c.ha.classList.add("hot");
  }

  function onComplexMove(e, c){
    if (!c.dragging || solved || !c.active) return;
    const pr = play.getBoundingClientRect();
    const x = (e.clientX - pr.left) - draggingComplex.offsetX;
    const y = (e.clientY - pr.top) - draggingComplex.offsetY;

    const maxX = pr.width - 220;
    const maxY = pr.height - 120;
    setPos(c, Math.max(0, Math.min(x, maxX)), Math.max(0, Math.min(y, maxY)));
  }

  function onComplexUp(c){
    if (!c.dragging || solved || !c.active) return;
    c.dragging = false;
    c.ha.classList.remove("hot");

    // must be cleaved to count (already ensured at pointerdown), but keep safety:
    if (!c.cleaved){
      showToast("TEV cleavage required");
      return;
    }

    if (inTube(c.el)){
      c.active = false;
      c.el.style.display = "none";
      captured += 1;
      updateCounters();

      if (captured >= REQUIRED) reveal();
      else respawn(c);
    }
  }

  function respawn(c){
    setTimeout(() => {
      if (solved) return;
      c.el.style.display = "block";
      c.active = true;
      c.dragging = false;

      // NEW complex needs cleavage again
      c.cleaved = false;
      c.ha.classList.remove("cleaved");
      c.ha.textContent = "HA";

      c.x = rand(-260, -60);
      c.y = rand(TOP_MIN_Y, TOP_MAX_Y);
      c.v = rand(FLOW_MIN_V, FLOW_MAX_V);
      setPos(c, c.x, c.y);
    }, 550);
  }

  // ===== TEV dragging =====
  function setTevPos(x, y){
    const pr = play.getBoundingClientRect();
    const tr = tev.getBoundingClientRect();
    const minX = 0, minY = 0;
    const maxX = pr.width  - tr.width;
    const maxY = pr.height - tr.height;
    tev.style.left = Math.min(Math.max(x, minX), maxX) + "px";
    tev.style.top  = Math.min(Math.max(y, minY), maxY) + "px";
  }

  function tevDown(e){
    if (solved) return;
    draggingTev = { pointerId: e.pointerId, offsetX: 0, offsetY: 0, startX: 0, startY: 0 };
    tev.setPointerCapture(e.pointerId);

    const pr = play.getBoundingClientRect();
    const tr = tev.getBoundingClientRect();
    const left = tr.left - pr.left;
    const top  = tr.top  - pr.top;
    draggingTev.startX = left;
    draggingTev.startY = top;

    draggingTev.offsetX = e.clientX - tr.left;
    draggingTev.offsetY = e.clientY - tr.top;
  }

  function tevMove(e){
    if (!draggingTev || solved) return;
    const pr = play.getBoundingClientRect();
    const x = (e.clientX - pr.left) - draggingTev.offsetX;
    const y = (e.clientY - pr.top) - draggingTev.offsetY;
    setTevPos(x, y);

    // highlight nearest uncleaved HA in range
    let any = false;
    complexes.forEach(c => {
      if (!c.active || c.cleaved) return;
      const hit = tevHitsHA(tev, c.ha);
      c.ha.classList.toggle("hot", hit);
      if (hit) any = true;
    });
    if (!any){
      complexes.forEach(c => c.ha.classList.remove("hot"));
    }
  }

  function tevUp(){
    if (!draggingTev || solved) return;

    // attempt cleavage: cleave the first uncleaved HA in range
    let cleavedOne = false;
    for (const c of complexes){
      if (!c.active || c.cleaved) continue;
      if (tevHitsHA(tev, c.ha)){
        c.cleaved = true;
        c.ha.classList.remove("hot");
        c.ha.classList.add("cleaved");
        c.ha.textContent = "HA‚úì";
        cleavedOne = true;
        showToast("TEV cleavage done ‚úÖ");
        if (navigator.vibrate) navigator.vibrate([20, 15, 20]);
        break;
      }
    }

    // clear highlights
    complexes.forEach(c => c.ha.classList.remove("hot"));

    // snap TEV back to its home position (nice UX)
    tev.style.left = "";
    tev.style.top  = "";

    if (!cleavedOne) {
      showToast("No HA in range");
      if (navigator.vibrate) navigator.vibrate(10);
    }

    draggingTev = null;
  }

  tev.addEventListener("pointerdown", tevDown);
  tev.addEventListener("pointermove", tevMove);
  tev.addEventListener("pointerup", tevUp);
  tev.addEventListener("pointercancel", tevUp);

  // ===== Animation loop (flow left -> right) =====
  let lastT = null;
  function tick(t){
    if (lastT == null) lastT = t;
    const dt = Math.min(32, t - lastT);
    lastT = t;

    const pr = play.getBoundingClientRect();

    if (!solved){
      complexes.forEach(c => {
        if (!c.active) return;
        if (c.dragging) return;

        c.x += c.v * dt;

        if (c.x > pr.width + 40){
          c.x = rand(-260, -60);
          c.y = rand(TOP_MIN_Y, TOP_MAX_Y);
          c.v = rand(FLOW_MIN_V, FLOW_MAX_V);

          // when it wraps, treat as a new arriving complex (needs TEV again)
          c.cleaved = false;
          c.ha.classList.remove("cleaved");
          c.ha.textContent = "HA";
        }

        setPos(c, c.x, c.y);
      });
    }

    requestAnimationFrame(tick);
  }

  // ===== Reset =====
  function reset(){
    solved = false;
    captured = 0;
    updateCounters();
    modal.classList.remove("show");

    complexes.splice(0).forEach(c => c.el.remove());
    for (let i = 0; i < COMPLEX_COUNT; i++) complexes.push(createComplex());

    // reset TEV to home (CSS position)
    tev.style.left = "";
    tev.style.top  = "";
    toast.classList.remove("show");
  }

  resetBtn.addEventListener("click", reset);
  closeBtn.addEventListener("click", () => modal.classList.remove("show"));
  modal.addEventListener("click", (e) => { if (e.target === modal) modal.classList.remove("show"); });

  // ===== Init =====
  updateCounters();
  for (let i = 0; i < COMPLEX_COUNT; i++) complexes.push(createComplex());
  requestAnimationFrame(tick);

  window.addEventListener("resize", () => {
    const pr = play.getBoundingClientRect();
    complexes.forEach(c => {
      if (!c.active) return;
      c.x = Math.min(c.x, pr.width - 220);
      c.y = Math.min(c.y, pr.height - 120);
      setPos(c, c.x, c.y);
    });
    tev.style.left = "";
    tev.style.top  = "";
  });
</script>
</body>
</html>
